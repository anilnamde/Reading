Chapter 1: Asynchrony: Now & Later
===================================

Asynchronous: 
    chunck of code that executes later part in code. ex: callback

Program as chunk:
    chunk that executes now and chunk that executes later 

    //later chunk
    function calculateSome(){
        some = some + 1;
    }
    //now chunk
    function now(){
        console.log(some)
    }
    now()
    setTimeout(calculateSome, 1000)
    now()

Async Console: 
    console API is async in nature and could cause strange output and browser or evironment need IO to print message which is slow hence execuation of console could be deffereed for some time. 
    So in such events rely upon debugger or on printing JSON.strigify.

Event Loop:
    - JS does not have notian on Asynchrony till ES6
    - JS engine runs inside a hosting environment browser or node
    - Event Loop: mechanism to execute multiple chunks one at each time
    - Once setTimeout is executed it puts code in event loop for execution

    event loop example simplified pseudocode:
    var eventLoop = [ ];
    var event;
    while (true) {
        // perform a "tick"
        if (eventLoop.length > 0) {
            // get the next event in the queue
            event = eventLoop.shift();
            // now, execute the next event
            try { 
                event();
            }
            catch (err) {
                reportError(err); 
            }
        }
    } 

Parallel Threading:
    Its prorcess and treads and might execute symultaneously on different processors 
    JS is single treaded environment
    If function order changes and it uses comman data order could affect output. But code becomes non deterministic.

Run-to-Completion:
    If there are two function then they will race to complete. In JS its single threaded so first function if starts will complete and then second

Concurrency (task level):
    Concurrency is when two or more "processes" are executing simultaneously
    ex: load more data as user scrolls down so two process/task 
    Single-threaded event loop is one expression of concurrency 
    scroll and response come after each other not symultaniously event loop takes care of it 

Noninteracting:
    If more than one process/task don't (need)interact, nondeterminism is perfectly acceptable.

Interaction:
    When functions/tasks should coordinate to avoid race conditions

    Ex A: to address race condidtion
    var res = [];
    function response(data) {
        if (data.url == "http://some.url.1") {
            res[0] = data; 
        }
        else if (data.url == "http://some.url.2") { 
            res[1] = data;
        } 
    }
    // ajax(..) is some arbitrary Ajax function given by a library
    ajax( "http://some.url.1", response ); 
    ajax( "http://some.url.2", response );

    Ex B: Race condition scenario
    //// Problem AJAX calls
    var a, b;
    function foo(x) { 
        a = x * 2;
        baz(); 
    }
    function bar(y) { 
        b = y * 2;
        baz(); 
    }
    function baz() { 
        console.log(a + b);
    }
    // ajax(..) is some arbitrary Ajax function given by a library
    ajax( "http://some.url.1", foo ); 
    ajax( "http://some.url.2", bar );

    //// To fix solutionis 
    var a, b;
    function foo(x) { a = x * 2;
        if (a && b) { 
            baz();
        } 
    }

    Ex C: Race condition scenario
    var a;
    function foo(x) { a = x * 2; baz(); }
    function bar(x) { a = x / 2; baz(); }
    function baz() { console.log( a );}
    // ajax(..) is some arbitrary Ajax function given by a library
    ajax( "http://some.url.1", foo ); ajax( "http://some.url.2", bar );

    //// Solution LATCH
    var a;
    function foo(x) { 
        if (!a) {
            a = x * 2;
            baz(); 
        }
    }

Cooperation:
    Long running tasks
    example : Ajax response handler that needs to run through a long list of results to transform the values. Scenario reads alot of values from server browser will get stuck user will not be able to do anything.

    var res = [];
    // `response(..)` receives array of results from the Ajax call 
    function response(data) {
        // add onto existing `res` array
        res = res.concat(
            // make a new transformed array with all `data` values doubled
            data.map( function(val){ return val * 2;}) 
        );
    }
    // ajax(..) is some arbitrary Ajax function given by a library
    ajax( "http://some.url.1", response ); 
    ajax( "http://some.url.2", response );

    ///////// simple solution would be to split chunk of data at a time
    var res = [];
    // `response(..)` receives array of results from the Ajax call 
    function response(data) {
        // let's just do 1000 at a time
        var chunk = data.splice( 0, 1000 );
        // add onto existing `res` array
        res = res.concat(
            // make a new transformed array with all `chunk` values doubled
            chunk.map( function(val){ return val * 2;}) 
        );
        if (data.length > 0) {
            // async schedule next batch setTimeout( function(){
            response( data ); }, 0 );
        } 
    }
    // ajax(..) is some arbitrary Ajax function given by a library
    ajax( "http://some.url.1", response ); 
    ajax( "http://some.url.2", response );

Jobs:
    ES6 brings Job queue like promises
    Whats diff between job queue and event loop: metaphor: the event loop queue is like an amusement park ride, where once you finish the ride, you have to go to the back of the line to ride again. But the Job queue is like finishing the ride, but then cutting in line and getting right back on.
    So Job queue is like execute later, but as soon as possible.

Statement Ordering:
    Order in which we write code need not be same in which JS engine executes code
    it's possible that the JS engine, after compiling this code and perform safe optimization

Review:


Chapter 2: Callbacks
==============================================================
    Callbacks are work horse of JavaScript but still there is need of cleaner absraction like promieses

Continuations:
    problem is that the moment callbacks come in picture code become difficult to react, understand and debug
    ex:
    // A
    setTimeout( function(){ // C}, 1000 ); 
    // B
Sequential Brain:
    It works like event loop while it focus on one thing at a time (excluding IMP funcition of respiration, breathing etc)  
Doing Versus Planning:
    Human brain works sequencially while planning and try solve one thing at a time. Problme with Asyn workflow is same as it hard to predict order in which it will execute.
Nested/Chained Callbacks:
    Callback hell is a problem. OR pyramid of doom. Such code is always difficult to understand as our brain try solve problems step by step aynch nature is just difficult to digest.

    ex:
    listen( "click", function handler(evt){ 
        setTimeout( function request(){
            ajax( "http://some.url.1", function response(text){ 
                if (text == "hello") {
                    handler(); 
                }
                else if (text == "world") { 
                    request();
                } 
            } );
        }, 500) ; 
    } )

    Understanding aynch flow in code is always difficult
    ex: 
    doA( function(){ 
        doB();
        doC( function(){ 
            doD();
        })
        doE(); 
    } );

    doF();

    Order in which they called : doA() doF() doB() doC() doE() doD(). If doA(..) or doD(..) aren't actually async then order of execution changes to doA() doB() doC() doD() doE() doF()

Trust Issues:
    When asyn code is called its control returning depends on third party(which we dont have control on) server OR api. 
    ex: order of code is codeA() codeB() ajax() as ajax() is async
        //codeA()
        ajax()
        //codeB()

Tale of Five Callbacks:
    Relying on thrid party async api is difficult (story of analitics calling payment method 5 time). Might need us to add more latches scenarios

Not Just Others' Code:
    Can we trust our own code ? 
    ex: add(a, b){
        return a+b;
    }

    what if a is passes as string ? sure you would keep adding checks for this. With callback involve it grows multifold

Trying to Save Callbacks:
    API design methods to handel aynch fall gracefully 
    1. split callbacks: 
        ex: ajax(suc, err)
    2. error-first style: 
        ex: ajax((err, res)=>{
                if(err){
                    handleErr()
                }else{
                    doSomething(res)
                }
            })

    ex:
    function result(data) { 
        console.log( a );
    }
    var a = 0;
    ajax( "..pre-cached-url..", result ); 
    a++;

    What will be output here 0 Or 1. Thats unpredictable callback async code

Review:

    We need a generalized solution to all of the trust issues, one that can be reused for as many callbacks as we create without all the extra boilerplate overhead. More sophisticated and capable async patterns


Chapter 3: Promises
================================
Callback philosophy is "here's what happens later, after the current step finishes."

But what if we could uninvert that inversion of control? What if instead of handing the continuation of our program to another party, we could expect it to return us a capability to know when its task finishes, and then our code could decide what to do next?
This paradigm is called Promises.










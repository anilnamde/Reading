Chapter 1: Asynchrony: Now & Later
===================================

Asynchronous: 
    chunck of code that executes later part in code. ex: callback

Program as chunk:
    chunk that executes now and chunk that executes later 

    //later chunk
    function calculateSome(){
        some = some + 1;
    }
    //now chunk
    function now(){
        console.log(some)
    }
    now()
    setTimeout(calculateSome, 1000)
    now()

Async Console: 
    console API is async in nature and could cause strange output and browser or evironment need IO to print message which is slow hence execuation of console could be deffereed for some time. 
    So in such events rely upon debugger or on printing JSON.strigify.

Event Loop:
    - JS does not have notian on Asynchrony till ES6
    - JS engine runs inside a hosting environment browser or node
    - Event Loop: mechanism to execute multiple chunks one at each time
    - Once setTimeout is executed it puts code in event loop for execution

    event loop example simplified pseudocode:
    var eventLoop = [ ];
    var event;
    while (true) {
        // perform a "tick"
        if (eventLoop.length > 0) {
            // get the next event in the queue
            event = eventLoop.shift();
            // now, execute the next event
            try { 
                event();
            }
            catch (err) {
                reportError(err); 
            }
        }
    } 

Parallel Threading:
    Its prorcess and treads and might execute symultaneously on different processors 
    JS is single treaded environment
    If function order changes and it uses comman data order could affect output. But code becomes non deterministic.

Run-to-Completion:
    If there are two function then they will race to complete. In JS its single threaded so first function if starts will complete and then second

Concurrency (task level):
    Concurrency is when two or more "processes" are executing simultaneously
    ex: load more data as user scrolls down so two process/task 
    Single-threaded event loop is one expression of concurrency 
    scroll and response come after each other not symultaniously event loop takes care of it 

Noninteracting:
    If more than one process/task don't (need)interact, nondeterminism is perfectly acceptable.

Interaction:
    When functions/tasks should coordinate to avoid race conditions

    Ex A: to address race condidtion
    var res = [];
    function response(data) {
        if (data.url == "http://some.url.1") {
            res[0] = data; 
        }
        else if (data.url == "http://some.url.2") { 
            res[1] = data;
        } 
    }
    // ajax(..) is some arbitrary Ajax function given by a library
    ajax( "http://some.url.1", response ); 
    ajax( "http://some.url.2", response );

    Ex B: Race condition scenario
    //// Problem AJAX calls
    var a, b;
    function foo(x) { 
        a = x * 2;
        baz(); 
    }
    function bar(y) { 
        b = y * 2;
        baz(); 
    }
    function baz() { 
        console.log(a + b);
    }
    // ajax(..) is some arbitrary Ajax function given by a library
    ajax( "http://some.url.1", foo ); 
    ajax( "http://some.url.2", bar );

    //// To fix solutionis 
    var a, b;
    function foo(x) { a = x * 2;
        if (a && b) { 
            baz();
        } 
    }

    Ex C: Race condition scenario
    var a;
    function foo(x) { a = x * 2; baz(); }
    function bar(x) { a = x / 2; baz(); }
    function baz() { console.log( a );}
    // ajax(..) is some arbitrary Ajax function given by a library
    ajax( "http://some.url.1", foo ); ajax( "http://some.url.2", bar );

    //// Solution LATCH
    var a;
    function foo(x) { 
        if (!a) {
            a = x * 2;
            baz(); 
        }
    }

Cooperation:
    Long running tasks
    example : Ajax response handler that needs to run through a long list of results to transform the values. Scenario reads alot of values from server browser will get stuck user will not be able to do anything.

    var res = [];
    // `response(..)` receives array of results from the Ajax call 
    function response(data) {
        // add onto existing `res` array
        res = res.concat(
            // make a new transformed array with all `data` values doubled
            data.map( function(val){ return val * 2;}) 
        );
    }
    // ajax(..) is some arbitrary Ajax function given by a library
    ajax( "http://some.url.1", response ); 
    ajax( "http://some.url.2", response );

    ///////// simple solution would be to split chunk of data at a time
    var res = [];
    // `response(..)` receives array of results from the Ajax call 
    function response(data) {
        // let's just do 1000 at a time
        var chunk = data.splice( 0, 1000 );
        // add onto existing `res` array
        res = res.concat(
            // make a new transformed array with all `chunk` values doubled
            chunk.map( function(val){ return val * 2;}) 
        );
        if (data.length > 0) {
            // async schedule next batch setTimeout( function(){
            response( data ); }, 0 );
        } 
    }
    // ajax(..) is some arbitrary Ajax function given by a library
    ajax( "http://some.url.1", response ); 
    ajax( "http://some.url.2", response );

Jobs:
    ES6 brings Job queue like promises
    Whats diff between job queue and event loop: metaphor: the event loop queue is like an amusement park ride, where once you finish the ride, you have to go to the back of the line to ride again. But the Job queue is like finishing the ride, but then cutting in line and getting right back on.
    So Job queue is like execute later, but as soon as possible.

Statement Ordering:
    Order in which we write code need not be same in which JS engine executes code
    it's possible that the JS engine, after compiling this code and perform safe optimization

Review:


Chapter 2: Callbacks
==============================================================
    Callbacks are work horse of JavaScript but still there is need of cleaner absraction like promieses

Continuations:
    problem is that the moment callbacks come in picture code become difficult to react, understand and debug
    ex:
    // A
    setTimeout( function(){ // C}, 1000 ); 
    // B
Sequential Brain:
    It works like event loop while it focus on one thing at a time (excluding IMP funcition of respiration, breathing etc)
Doing Versus Planning:










